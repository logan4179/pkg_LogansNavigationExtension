using System.Collections;
using System.Collections.Generic;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using LogansNavigationExtension;
using UnityEngine.AI;
using JetBrains.Annotations;
using System.IO;
using static UnityEngine.Networking.UnityWebRequest;

namespace LoganLand.LogansNavmeshExtension.Tests
{
    public class A_SetUpTests
    {
        NavMeshTriangulation _nmTriangulation;

        string filePath_lnx_navmesh = $"{Directory.GetCurrentDirectory()}\\Packages\\LogansNavigationExtension\\Testing\\Unit Tests\\Test Data\\nm_B.json";
        /// <summary>
		/// The LNX_NavMesh that gets generated by the test, when the tests is ran, from the scene geometry.
		/// </summary>
		LNX_NavMesh _generatedLnxNavmesh;

		LNX_MeshManipulator _lnx_meshManipulator;

        string filePath_test_SamplePosition = $"{Directory.GetCurrentDirectory()}\\Packages\\LogansNavigationExtension\\Testing\\Unit Tests\\Test Data\\SamplePosition_data_A.json";
        Test_SamplePosition _test_samplePosition;

		string filePath_test_closestOnPerimeter = $"{Directory.GetCurrentDirectory()}\\Packages\\LogansNavigationExtension\\Testing\\Unit Tests\\Test Data\\closestOnPerimeter_data_A.json";
		LNX_TestClosestOnPerimeter _test_closestOnPerimeter;

		/// <summary>Saved LNX_NavMesh that gets saved and reconstructed from JSON represented the expected state/values for the 
		/// checking tests. Note: This should ideally be the exact same as the generated navmesh. The idea is that this can 
		/// serialize (store) certain predictable, saveable, values, like the bounds positions/size, and then compared to the 
		/// dynamically-constructed lnx navmesh. Therefore, this object should be re-serialized to json anytime I make a change 
		/// to the scene geometry that makes the navmesh.</summary>
		LNX_NavMesh _serializedLnxNavmesh; //note: originally I was going to use this to save the _mesh and triangulation collection lengths instead of testing a hard-coded value, but those things don't seem to get serialized to JSON. Leaving this here in case I think of something else to do with it...
		string filePath_test_serializedLnxNavmesh = $"{Directory.GetCurrentDirectory()}\\Packages\\LogansNavigationExtension\\Testing\\Unit Tests\\Test Data\\expectedNM_A.json";


		#region A - Setup Tests---------------------------------------------------------------------------
		[Test]
		public void a1_SetUpObjects()
        {
			#region HANDLE EXISTING SCENE NAVMESH ----------------------------------------------------------------
			LNX_NavMesh existingSceneMesh = GameObject.Find("[LNX_Navmesh]").GetComponent<LNX_NavMesh>();
			if ( existingSceneMesh != null )
			{
				Debug.Log($"found scene navmesh. now disabling...");
				existingSceneMesh.enabled = false;
			}
			else
			{
				Debug.LogWarning($"Didn't find scene navmesh...");
			}
			#endregion

			GameObject go = new GameObject();
			go.name = "TestLNX_Navmesh"; //so that other test scripts can find this object.

			_generatedLnxNavmesh = go.AddComponent<LNX_NavMesh>();

			_lnx_meshManipulator = go.AddComponent<LNX_MeshManipulator>();
			_lnx_meshManipulator._LNX_NavMesh = _generatedLnxNavmesh;

			_lnx_meshManipulator.ClearSelection(); //Not doing this was causing an error...

			Assert.NotNull( _generatedLnxNavmesh );


			//Note: decided not to do the following lines which create a navmesh from json because the navmesh is setup by 
			//a navmeshtriangulation object, which needs to be tested...
			//Debug.Log (File.Exists(filePath_lnx_navmesh) );
			// Debug.Log(filePath_lnx_navmesh);
			//jsonString = File.ReadAllText(filePath_lnx_navmesh);
			//Debug.Log( nmJsonString );
			//nm = JsonUtility.FromJson<LNX_NavMesh>( nmJsonString ); //note: this won't work bc FromJson() doesn't support deserializing a monobehavior object
			//JsonUtility.FromJsonOverwrite(jsonString, nm); //note: this apparently does work to deserialize a monobehaviour...
			//Debug.Log(nm.Triangles.Length);

			GameObject go_serializedNavmesh = new GameObject();
			go_serializedNavmesh.name = "SerializedNavmesh"; //so that other test scripts can find this
			_serializedLnxNavmesh = go_serializedNavmesh.AddComponent<LNX_NavMesh>();
			string jsonString = File.ReadAllText( filePath_test_serializedLnxNavmesh );
			JsonUtility.FromJsonOverwrite( jsonString, _serializedLnxNavmesh );

			Assert.NotNull( _serializedLnxNavmesh );

		}

		[Test]
        public void a2_CalculateTriangulation()
        {
			_nmTriangulation = NavMesh.CalculateTriangulation();
			Debug.Log($"{nameof(NavMesh.CalculateTriangulation)} calculated '{_nmTriangulation.vertices}' vertices, '{_nmTriangulation.areas}' areas, and '{_nmTriangulation.indices}' indices.");

			_generatedLnxNavmesh.LayerMaskName = "lr_EnvSolid"; //not necessary, but just to be sure...
			_generatedLnxNavmesh.CalculateTriangulation();

            Assert.AreEqual( _nmTriangulation.areas.Length, _generatedLnxNavmesh.Triangles.Length );
        }

		// TRIANGULATION ---------------------------------------------------------------------------------------------
		int expectedNumberOfAreas = 84;
		[Test]
		public void a3_checkTriangulationAreasArrayLength()
		{
			Debug.Log($"{nameof(a3_checkTriangulationAreasArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_generatedLnxNavmesh.OriginalTriangulation.areas == null}'");
			Debug.Log($"Checking that generated LNX_NavMesh.OriginalTriangulation.areas length ('{_generatedLnxNavmesh.OriginalTriangulation.areas.Length}')..." +
				$"was the same as the expected number of '{expectedNumberOfAreas}'.");

			Assert.AreEqual( _generatedLnxNavmesh.OriginalTriangulation.areas.Length, expectedNumberOfAreas );
		}

		int expectedNumberOfVerts = 75;
		[Test]
		public void a3_checkTriangulationVerticesArrayLength()
		{
			Debug.Log($"{nameof(a3_checkTriangulationVerticesArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_generatedLnxNavmesh.OriginalTriangulation.vertices == null}'");

			Assert.AreEqual( expectedNumberOfVerts, _generatedLnxNavmesh.OriginalTriangulation.vertices.Length );
		}

		[Test]
		public void a3_checkTriangulationIndicesArrayLength()
		{
			Debug.Log($"{nameof(a3_checkTriangulationIndicesArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_generatedLnxNavmesh.OriginalTriangulation.vertices == null}'");

			Assert.AreEqual(_generatedLnxNavmesh.OriginalTriangulation.indices.Length, expectedNumberOfAreas * 3);
		}

		// MESH -------------------------------------------------------------------------------------------------------
		[Test]
		public void a4_checkMeshTrianglesArrayLength()
		{
			Debug.Log($"{nameof(a4_checkMeshTrianglesArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_generatedLnxNavmesh._Mesh.triangles == null}'");

			Assert.AreEqual( _generatedLnxNavmesh._Mesh.triangles.Length, expectedNumberOfAreas * 3 );
		}

		[Test]
		public void a4_checkMeshVerticesArrayLength()
		{
			Debug.Log($"{nameof(a4_checkMeshVerticesArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_generatedLnxNavmesh._Mesh.vertices == null}'");

			Assert.AreEqual( _generatedLnxNavmesh._Mesh.vertices.Length, expectedNumberOfVerts );
		}

		[Test]
		public void a4_checkMeshNormalsArrayLength()
		{
			Debug.Log($"{nameof(a4_checkMeshNormalsArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_generatedLnxNavmesh._Mesh.normals == null}'");

			Assert.AreEqual( _generatedLnxNavmesh._Mesh.normals.Length, expectedNumberOfVerts );
		}

		// TRIANGLES COLLECTION --------------------------------------------------------------------------------------
		[Test]
		public void a5_CheckTriIndices()
		{
			for ( int i = 0; i < _generatedLnxNavmesh.Triangles.Length; i++ )
			{
				Debug.Log($"{i}...");

				Debug.Log( $"checking Index_inCollection..." );
				Assert.Greater( _generatedLnxNavmesh.Triangles[i].Index_inCollection, -1 );

				Debug.Log($"checking AreaIndex...");
				Assert.Greater(_generatedLnxNavmesh.Triangles[i].AreaIndex, -1);
			}
		}

		[Test]
		public void a5_CheckVertIndices()
		{
			for (int i = 0; i < _generatedLnxNavmesh.Triangles.Length; i++)
			{
				Debug.Log($"{i}...");

				Debug.Log($"checking indices of vert[0]...");
				Debug.Log($"Verts[0].MeshIndex_triangles: '{_generatedLnxNavmesh.Triangles[i].Verts[0].MeshIndex_triangles}'");
				Assert.Greater(_generatedLnxNavmesh.Triangles[i].Verts[0].MeshIndex_triangles, -1);
				Assert.Less(_generatedLnxNavmesh.Triangles[i].Verts[0].MeshIndex_triangles, _generatedLnxNavmesh._Mesh.triangles.Length);

				Debug.Log($"Verts[0].MeshIndex_vertices: '{_generatedLnxNavmesh.Triangles[i].Verts[0].MeshIndex_vertices}'");
				Assert.Greater(_generatedLnxNavmesh.Triangles[i].Verts[0].MeshIndex_vertices, -1);
				Assert.Less(_generatedLnxNavmesh.Triangles[i].Verts[0].MeshIndex_vertices, _generatedLnxNavmesh._Mesh.vertices.Length);


			}
		}

		[Test]
		public void a6_Bounds_Tests()
		{
			Debug.Log($"\nChecking bounds...");

			// CENTER-------------------------------------------------------
			UnityEngine.Assertions.Assert.AreApproximatelyEqual( _generatedLnxNavmesh.V_BoundsCenter.x, _serializedLnxNavmesh.V_BoundsCenter.x );
			UnityEngine.Assertions.Assert.AreApproximatelyEqual( _generatedLnxNavmesh.V_BoundsCenter.y, _serializedLnxNavmesh.V_BoundsCenter.y );
			UnityEngine.Assertions.Assert.AreApproximatelyEqual( _generatedLnxNavmesh.V_BoundsCenter.z, _serializedLnxNavmesh.V_BoundsCenter.z );

			// BOUNDS-------------------------------------------------------
			for( int i = 0; i < 6; i++ )
			{
				Debug.Log($"{i}...");

				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _generatedLnxNavmesh.V_Bounds[i].x, _serializedLnxNavmesh.V_Bounds[i].x );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _generatedLnxNavmesh.V_Bounds[i].y, _serializedLnxNavmesh.V_Bounds[i].y );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _generatedLnxNavmesh.V_Bounds[i].z, _serializedLnxNavmesh.V_Bounds[i].z );
			}
		}

		[Test]
		public void a7_Relationships_Tests()
		{
			Debug.Log($"\nChecking relationships...");
			for ( int i = 0; i < _generatedLnxNavmesh.Triangles.Length; i++ )
			{
				Debug.Log($"checking tri '{i}'...");

				Assert.AreEqual( _generatedLnxNavmesh.Triangles[i].Relationships.Length, _generatedLnxNavmesh.Triangles.Length );

				Assert.Greater( _generatedLnxNavmesh.Triangles[i].AdjacentTriIndices.Length, 0 );
			}
		}

		/*
		[Test]
		public void aX_AllVertsUnique()
		{
			//todo: check that no triangles have verts occupying the same space
		}
		*/

		/*
		[Test]
		public void aX_SharedVertexCoordinates_Tests()
		{
			//TODO: Check that multiple vertices have the expected sharedvertex coordinates...
			Debug.Log($"\nChecking SharedVertexCoordinates...");

		}
		*/

		/*
		[Test]
		public void aX_Modifications_Tests()
		{
			//TODO: Test modifications when I can figure out how I want to do this...
			Debug.Log($"\nChecking modifications...");

		}
		*/
		#endregion

		#region B - LNX_Navmesh function Tests---------------------------------------------------------------------------
		[Test]
        public void b1_SamplePosition_Tests()
        {
			Debug.Log($"Creating test object from json...");

			if ( !File.Exists(filePath_test_SamplePosition) )
			{
				Debug.LogError( $"PROBLEM!!!!! file at test path does not exist. Cannot perform test." );
				return;
			}

			#region SETUP TEST OBJECT-----------------------------
			_test_samplePosition = _generatedLnxNavmesh.gameObject.AddComponent<Test_SamplePosition>();
			//Debug.Log ( File.Exists(filePath_test_SamplePosition) );
			//Debug.Log( filePath_test_SamplePosition );
			string jsonString = File.ReadAllText(filePath_test_SamplePosition);

			JsonUtility.FromJsonOverwrite(jsonString, _test_samplePosition);
			//Debug.Log( _test_samplePosition.problemPositions.Count );

			Assert.IsNotNull(_test_samplePosition.testPositions);
			Assert.Greater(_test_samplePosition.testPositions.Count, 0);
			#endregion

			for ( int i = 0; i < _test_samplePosition.testPositions.Count; i++ )
			{
				Debug.Log($"{i}...");
				LNX_ProjectionHit hit = new LNX_ProjectionHit();
				_generatedLnxNavmesh.SamplePosition( _test_samplePosition.testPositions[i], out hit, 10f );
				//Assert.AreEqual( _test_samplePosition.hitPositions[i], hit.Position ); //got rounding point issue
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.hitPositions[i].x, hit.HitPosition.x );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.hitPositions[i].y, hit.HitPosition.y );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.hitPositions[i].z, hit.HitPosition.z );

				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.triCenters[i].x, _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.x );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.triCenters[i].y, _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.y );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.triCenters[i].z, _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.z );
			}
		}

		[Test]
		public void b2_Test_ClosestOnPerimeter()
		{
			Debug.Log($"Creating test object from json...");

			if ( !File.Exists(filePath_test_closestOnPerimeter) )
			{
				Debug.LogError($"PROBLEM!!!!! file at test path does not exist. Cannot perform test.");
				return;
			}

			#region SETUP CLOSEST ON PERIMETER TEST -----------------------------
			_test_closestOnPerimeter = _generatedLnxNavmesh.gameObject.AddComponent<LNX_TestClosestOnPerimeter>();
			//Debug.Log ( File.Exists(filePath_test_closestOnPerimeter) );
			//Debug.Log( filePath_test_closestOnPerimeter );
			string jsonString = File.ReadAllText(filePath_test_closestOnPerimeter);

			JsonUtility.FromJsonOverwrite(jsonString, _test_closestOnPerimeter);
			//Debug.Log( _test_samplePosition.problemPositions.Count );

			Assert.IsNotNull(_test_closestOnPerimeter.testPositions);
			Assert.Greater(_test_closestOnPerimeter.testPositions.Count, 0);
			#endregion

			for ( int i = 0; i < _test_closestOnPerimeter.testPositions.Count; i++ )
			{
				Debug.Log($"{i}. expecting: '{_test_closestOnPerimeter.resultPositions[i]}'...");

				LNX_ProjectionHit hit = new LNX_ProjectionHit();

				if ( _generatedLnxNavmesh.SamplePosition(_test_closestOnPerimeter.testPositions[i], out hit, 10f) ) //It needs to do this in order to decide which triangle to use...
				{
					Vector3 v_result = _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].ClosestPointOnPerimeter( _test_closestOnPerimeter.testPositions[i] );

					UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_closestOnPerimeter.resultPositions[i].x, v_result.x );
					UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_closestOnPerimeter.resultPositions[i].y, v_result.y );
					UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_closestOnPerimeter.resultPositions[i].z, v_result.z );
				}
			}
		}

		[Test]
		public void b3_Test_ClosestOnPerimeter_triCenters()
		{
			Debug.Log($"{nameof(b3_Test_ClosestOnPerimeter_triCenters)}---------------------------------------------------------");
			Debug.Log($"Sampling '{_test_closestOnPerimeter.testPositions.Count}' test positions at: '{System.DateTime.Now.ToString()}'");

			for (int i = 0; i < _test_closestOnPerimeter.testPositions.Count; i++)
			{
				Debug.Log($"{i}. expecting: '{_test_closestOnPerimeter.resultPositions[i]}'...");

				LNX_ProjectionHit hit = new LNX_ProjectionHit();

				if (_generatedLnxNavmesh.SamplePosition(_test_closestOnPerimeter.testPositions[i], out hit, 10f)) //It needs to do this in order to decide which triangle to use...
				{
					Vector3 v_result = _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].ClosestPointOnPerimeter(_test_closestOnPerimeter.testPositions[i]);

					UnityEngine.Assertions.Assert.AreApproximatelyEqual(_test_closestOnPerimeter.triCenters[i].x, _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.x);
					UnityEngine.Assertions.Assert.AreApproximatelyEqual(_test_closestOnPerimeter.triCenters[i].y, _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.y);
					UnityEngine.Assertions.Assert.AreApproximatelyEqual(_test_closestOnPerimeter.triCenters[i].z, _generatedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.z);
				}
			}

			Debug.Log($"end of test: '{nameof(b3_Test_ClosestOnPerimeter_triCenters)}'");
		}
		#endregion


		/*
		 * 
		[Test]
		public void x_Test_SelectCutEdge()
		{
			//make tests showing that I can and cannot cut edges in various scenarios
		}
		*/


		/*
        // A UnityTest behaves like a coroutine in Play Mode. In Edit Mode you can use
        // `yield return null;` to skip a frame.
        [UnityTest]
        public IEnumerator LNXEditModeTestsWithEnumeratorPasses()
        {
            // Use the Assert class to test conditions.
            // Use yield to skip a frame.

			yield return null;
        }
		*/

	}
}


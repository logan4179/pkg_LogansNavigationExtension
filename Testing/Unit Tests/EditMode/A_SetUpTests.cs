using System.Collections;
using System.Collections.Generic;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using LogansNavigationExtension;
using UnityEngine.AI;
using JetBrains.Annotations;
using System.IO;
using static UnityEngine.Networking.UnityWebRequest;
using System.Linq;

namespace LoganLand.LogansNavmeshExtension.Tests
{
    public class A_SetUpTests
    {
        NavMeshTriangulation _nmTriangulation;

        /// <summary>
		/// The LNX_NavMesh that gets generated by the test, when the tests is ran, from the scene geometry.
		/// </summary>
		LNX_NavMesh _sceneGeneratedLnxNavmesh;

		/// <summary>Saved LNX_NavMesh that gets saved and reconstructed from JSON represented the expected state/values for the 
		/// checking tests. Note: This should ideally be the exact same as the generated navmesh. The idea is that this can 
		/// serialize (store) certain predictable, saveable, values, like the bounds positions/size, and then compared to the 
		/// dynamically-constructed lnx navmesh. Therefore, this object should be re-serialized to json anytime I make a change 
		/// to the scene geometry that makes the navmesh.</summary>
		LNX_NavMesh _serializedLnxNavmesh; //note: originally I was going to use this to save the _mesh and triangulation collection lengths instead of testing a hard-coded value, but those things don't seem to get serialized to JSON. Leaving this here in case I think of something else to do with it...

		LNX_MeshManipulator _sceneGeneratedMeshManipulator, _serializedMeshManipulator;

        TDG_SamplePosition _test_samplePosition;

		TDG_SampleClosestPtOnPerimeter _test_closestOnPerimeter;

		int expectedNumberOfAreasFromTriangulation = 84;
		int expectedNumberOfUniqueVertsAfterTriangulation = 75;


		#region A - Setup Tests---------------------------------------------------------------------------
		[Test]
		public void a1_CreateAndSetUpObjectsInTheScene()
        {
			#region FIND/HANDLE EXISTING SCENE NAVMESH ----------------------------------------------------------------
			LNX_NavMesh existingSceneMesh = GameObject.Find(LNX_UnitTestUtilities.Name_ExistingSceneNavmeshGameobject).GetComponent<LNX_NavMesh>();

			if ( existingSceneMesh != null )
			{
				Debug.Log($"found scene navmesh. now disabling...");
				existingSceneMesh.enabled = false;
			}
			else
			{
				Debug.LogWarning($"Didn't find scene navmesh...");
			}

			Assert.NotNull( existingSceneMesh );
			#endregion

			#region SETUP SCENE-GENERATED NAVMESH ---------------------------------------------------------------------
			GameObject go = new GameObject();
			go.name = LNX_UnitTestUtilities.Name_GeneratedNavmeshGameobject; //so that other test scripts can find this object.

			_sceneGeneratedLnxNavmesh = go.AddComponent<LNX_NavMesh>();
			Assert.NotNull( _sceneGeneratedLnxNavmesh );

			_sceneGeneratedMeshManipulator = go.AddComponent<LNX_MeshManipulator>();
			_sceneGeneratedMeshManipulator._LNX_NavMesh = _sceneGeneratedLnxNavmesh;
			Assert.NotNull( _sceneGeneratedMeshManipulator );
			#endregion

			_sceneGeneratedMeshManipulator.ClearSelection(); //Not doing this was causing an error...

			#region SETUP SERIALIZED NAVMESH ---------------------------------------------------------------------
			GameObject go_serializedNavmesh = new GameObject();
			go_serializedNavmesh.name = LNX_UnitTestUtilities.Name_SerializedNavmeshGameobject; //so that other test scripts can find this
			_serializedLnxNavmesh = go_serializedNavmesh.AddComponent<LNX_NavMesh>();
			string jsonString = File.ReadAllText( TDG_Manager.filePath_serializedLnxNavMesh );
			JsonUtility.FromJsonOverwrite( jsonString, _serializedLnxNavmesh );

			Assert.NotNull( _serializedLnxNavmesh );

			_serializedLnxNavmesh.ReconstructVisualizationMesh();

			_serializedMeshManipulator = go_serializedNavmesh.AddComponent<LNX_MeshManipulator>();
			_serializedMeshManipulator._LNX_NavMesh = _serializedLnxNavmesh;
			Assert.NotNull( _serializedMeshManipulator );
			#endregion
		}

		[Test]
        public void a2_CheckNumberOfTrisAndVertsOnSceneGeneratedMeshIsCorrect()
        {
			_nmTriangulation = NavMesh.CalculateTriangulation();
			Debug.Log($"{nameof(NavMesh.CalculateTriangulation)} calculated '{_nmTriangulation.vertices}' vertices, '{_nmTriangulation.areas}' areas, and '{_nmTriangulation.indices}' indices.");

			_sceneGeneratedLnxNavmesh.LayerMaskName = "lr_EnvSolid"; //not necessary, but just to be sure...
			_sceneGeneratedLnxNavmesh.CalculateTriangulation();

            Assert.AreEqual( expectedNumberOfAreasFromTriangulation, _sceneGeneratedLnxNavmesh.Triangles.Length );
			Assert.AreEqual( expectedNumberOfAreasFromTriangulation, _nmTriangulation.areas.Length );
			Assert.AreEqual( expectedNumberOfAreasFromTriangulation * 3, _sceneGeneratedLnxNavmesh._Mesh.triangles.Length );
			Assert.AreEqual( expectedNumberOfUniqueVertsAfterTriangulation, _sceneGeneratedLnxNavmesh._Mesh.vertices.Length );
		}

		public static int largestMeshVisIndex_sceneGenerated = 0; //public and static, because I need to cache this and use it in another test file...
		public static int largestMeshVisINdex_serialized = 0; //public and static, because I need to cache this and use it in another test file...
		[Test]
		public void a3_CheckThatGreatestVisMeshIndexIsSameAsMeshVerticesArrayLength()
		{
			Debug.Log($"Finding largest mesh vis index for meshes...");
			for ( int i_triangles = 0; i_triangles < _sceneGeneratedLnxNavmesh.Triangles.Length; i_triangles++ )
			{
				for ( int i_verts = 0; i_verts < 3; i_verts++ )
				{
					if ( _sceneGeneratedLnxNavmesh.Triangles[i_triangles].Verts[i_verts].Index_VisMesh_Vertices > largestMeshVisIndex_sceneGenerated )
					{
						largestMeshVisIndex_sceneGenerated = _sceneGeneratedLnxNavmesh.Triangles[i_triangles].Verts[i_verts].Index_VisMesh_Vertices;
					}
				}
			}

			Debug.Log($"End of search. largest vis mesh index was: '{largestMeshVisIndex_sceneGenerated}'...");
			Assert.AreEqual( _sceneGeneratedLnxNavmesh._Mesh.vertices.Length - 1, largestMeshVisIndex_sceneGenerated );

			for (int i_triangles = 0; i_triangles < _serializedLnxNavmesh.Triangles.Length; i_triangles++)
			{
				for (int i_verts = 0; i_verts < 3; i_verts++)
				{
					if (_serializedLnxNavmesh.Triangles[i_triangles].Verts[i_verts].Index_VisMesh_Vertices > largestMeshVisINdex_serialized)
					{
						largestMeshVisINdex_serialized = _serializedLnxNavmesh.Triangles[i_triangles].Verts[i_verts].Index_VisMesh_Vertices;
					}
				}
			}

			Debug.Log($"End of search over serialized navmesh. largest vis mesh index was: '{largestMeshVisINdex_serialized}'...");

			Assert.AreEqual(_serializedLnxNavmesh._Mesh.vertices.Length - 1, largestMeshVisIndex_sceneGenerated );

		}

		[Test]
		public void a4_SetUpVisualizationMeshOnSerializedLnxNavmesh()
		{
			Debug.Log($"_Mesh object currently null?: '{_serializedLnxNavmesh._Mesh == null}'. Trying to recreate mesh object...");
			Assert.NotNull(_serializedLnxNavmesh._Mesh);

			Debug.Log($"regenerated mesh visual. {nameof(_serializedLnxNavmesh._Mesh.vertices)} length: '{_serializedLnxNavmesh._Mesh.vertices.Length}', " +
				$"{nameof(_serializedLnxNavmesh._Mesh.triangles)} length: '{_serializedLnxNavmesh._Mesh.triangles.Length}, " +
				$"{nameof(_serializedLnxNavmesh._Mesh.normals)} length: '{_serializedLnxNavmesh._Mesh.normals.Length}, ");

			Assert.AreEqual( _serializedLnxNavmesh._Mesh.triangles.Length, expectedNumberOfAreasFromTriangulation * 3 );

			Assert.AreEqual( _serializedLnxNavmesh._Mesh.vertices.Length, expectedNumberOfUniqueVertsAfterTriangulation );
		}


		#endregion

		#region B) CHECK OBJECTS ------------------------------------------------------------------------------------------
		[Test]
		public void b1_CheckTriIndices()
		{
			for ( int i = 0; i < _sceneGeneratedLnxNavmesh.Triangles.Length; i++ )
			{
				Debug.Log($"{i}...");

				Debug.Log( $"checking Index_inCollection..." );
				Assert.Greater( _sceneGeneratedLnxNavmesh.Triangles[i].Index_inCollection, -1 );

				Debug.Log($"checking AreaIndex...");
				Assert.Greater(_sceneGeneratedLnxNavmesh.Triangles[i].AreaIndex, -1);
			}
		}

		[Test]
		public void b2_CheckVertIndices()
		{
			for (int i = 0; i < _sceneGeneratedLnxNavmesh.Triangles.Length; i++)
			{
				Debug.Log($"{i}...");

				Debug.Log($"checking indices of vert[0]...");
				Debug.Log($"Verts[0].MeshIndex_triangles: '{_sceneGeneratedLnxNavmesh.Triangles[i].Verts[0].Index_VisMesh_triangles}'");
				Assert.Greater(_sceneGeneratedLnxNavmesh.Triangles[i].Verts[0].Index_VisMesh_triangles, -1);
				Assert.Less(_sceneGeneratedLnxNavmesh.Triangles[i].Verts[0].Index_VisMesh_triangles, _sceneGeneratedLnxNavmesh._Mesh.triangles.Length);

				Debug.Log($"Verts[0].MeshIndex_vertices: '{_sceneGeneratedLnxNavmesh.Triangles[i].Verts[0].Index_VisMesh_Vertices}'");
				Assert.Greater(_sceneGeneratedLnxNavmesh.Triangles[i].Verts[0].Index_VisMesh_Vertices, -1);
				Assert.Less(_sceneGeneratedLnxNavmesh.Triangles[i].Verts[0].Index_VisMesh_Vertices, _sceneGeneratedLnxNavmesh._Mesh.vertices.Length);


			}
		}

		[Test]
		public void b3_Bounds_Tests()
		{
			Debug.Log($"\nChecking bounds...");

			// CENTER-------------------------------------------------------
			UnityEngine.Assertions.Assert.AreApproximatelyEqual( _sceneGeneratedLnxNavmesh.V_BoundsCenter.x, _serializedLnxNavmesh.V_BoundsCenter.x );
			UnityEngine.Assertions.Assert.AreApproximatelyEqual( _sceneGeneratedLnxNavmesh.V_BoundsCenter.y, _serializedLnxNavmesh.V_BoundsCenter.y );
			UnityEngine.Assertions.Assert.AreApproximatelyEqual( _sceneGeneratedLnxNavmesh.V_BoundsCenter.z, _serializedLnxNavmesh.V_BoundsCenter.z );

			// BOUNDS-------------------------------------------------------
			for( int i = 0; i < 6; i++ )
			{
				Debug.Log($"{i}...");

				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _sceneGeneratedLnxNavmesh.V_Bounds[i].x, _serializedLnxNavmesh.V_Bounds[i].x );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _sceneGeneratedLnxNavmesh.V_Bounds[i].y, _serializedLnxNavmesh.V_Bounds[i].y );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _sceneGeneratedLnxNavmesh.V_Bounds[i].z, _serializedLnxNavmesh.V_Bounds[i].z );
			}
		}

		[Test]
		public void b4_Relationships_Tests()
		{
			Debug.Log($"\nChecking relationships...");
			Debug.Log($"Running through '{_sceneGeneratedLnxNavmesh.Triangles.Length}' triangles to check relationships..");
			for ( int i = 0; i < _sceneGeneratedLnxNavmesh.Triangles.Length; i++ )
			{
				Debug.Log($"checking tri '{i}'...");

				Assert.AreEqual( _sceneGeneratedLnxNavmesh.Triangles[i].Relationships.Length, _sceneGeneratedLnxNavmesh.Triangles.Length );

				Assert.Greater( _sceneGeneratedLnxNavmesh.Triangles[i].AdjacentTriIndices.Length, 0 );
			}
		}
		#endregion

		#region C) CHECK VISUALIZATION MESH ------------------------------------------------------------------------------------------
		[Test]
		public void c1_checkMeshTrianglesArrayLength()
		{
			Debug.Log($"{nameof(c1_checkMeshTrianglesArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_sceneGeneratedLnxNavmesh._Mesh.triangles == null}'");

			Assert.AreEqual( _sceneGeneratedLnxNavmesh._Mesh.triangles.Length, expectedNumberOfAreasFromTriangulation * 3 );
		}

		[Test]
		public void c2_checkMeshVerticesArrayLength()
		{
			Debug.Log($"{nameof(c2_checkMeshVerticesArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_sceneGeneratedLnxNavmesh._Mesh.vertices == null}'");

			Assert.AreEqual( _sceneGeneratedLnxNavmesh._Mesh.vertices.Length, expectedNumberOfUniqueVertsAfterTriangulation );
		}

		[Test]
		public void c3_checkMeshNormalsArrayLength()
		{
			Debug.Log($"{nameof(c3_checkMeshNormalsArrayLength)}()---------------------------------");
			Debug.Log($"collection null: '{_sceneGeneratedLnxNavmesh._Mesh.normals == null}'");

			Assert.AreEqual( _sceneGeneratedLnxNavmesh._Mesh.normals.Length, expectedNumberOfUniqueVertsAfterTriangulation );
		}

		[Test]
		public void c4_checkAllVisualizationMeshVerticesHaveCounterpart()
		{
			Debug.Log($"{nameof(c4_checkAllVisualizationMeshVerticesHaveCounterpart)}()---------------------------------");

			for ( int i = 0; i < _sceneGeneratedLnxNavmesh._Mesh.vertices.Length; i++ )
			{
				Debug.Log($"iterating mesh vertex: '{i}' at pos: '{_sceneGeneratedLnxNavmesh._Mesh.vertices[i]}'...");
				bool haveFound = false;

				for ( int i_triangles = 0; i_triangles < _sceneGeneratedLnxNavmesh.Triangles.Length; i_triangles++ )
				{
					//Debug.Log($"iterating triangle: '{j}'...");

					for (int i_vrts = 0; i_vrts < 3; i_vrts++)
					{
						if ( _sceneGeneratedLnxNavmesh.Triangles[i_triangles].GetVertIndextAtPosition(_sceneGeneratedLnxNavmesh._Mesh.vertices[i]) > -1 )
						{
							haveFound = true;
						}
					}
				}

				Assert.IsTrue( haveFound );
			}
		}
		#endregion

		/*
		[Test]
		public void aX_AllVertsUnique()
		{
			//todo: check that no triangles have verts occupying the same space
		}
		*/

		/*
		[Test]
		public void aX_SharedVertexCoordinates_Tests()
		{
			//TODO: Check that multiple vertices have the expected sharedvertex coordinates...
			Debug.Log($"\nChecking SharedVertexCoordinates...");

		}
		*/

		/*
		[Test]
		public void aX_Modifications_Tests()
		{
			//TODO: Test modifications when I can figure out how I want to do this...
			Debug.Log($"\nChecking modifications...");

		}
		*/

		//TODO: these following tests need to be in their own separate script
		#region B - LNX_Navmesh function Tests---------------------------------------------------------------------------
		[Test]
        public void b1_SamplePosition_Tests() //todo: I think these need to be ran against the serialized navmesh
        {
			Debug.Log($"Creating test object from json...");

			if ( !File.Exists(TDG_Manager.filePath_testData_SamplePosition) )
			{
				Debug.LogError( $"PROBLEM!!!!! file at test path does not exist. Cannot perform test." );
				return;
			}

			#region SETUP TEST OBJECT-----------------------------
			_test_samplePosition = _serializedLnxNavmesh.gameObject.AddComponent<TDG_SamplePosition>();

			string jsonString = File.ReadAllText( TDG_Manager.filePath_testData_SamplePosition );

			JsonUtility.FromJsonOverwrite(jsonString, _test_samplePosition);

			Assert.IsNotNull(_test_samplePosition.testPositions);
			Assert.Greater(_test_samplePosition.testPositions.Count, 0);
			#endregion

			Debug.Log($"Now sampling '{_test_samplePosition.testPositions.Count}' test positions...");
			for ( int i = 0; i < _test_samplePosition.testPositions.Count; i++ )
			{
				Debug.Log($"{i}...");
				LNX_ProjectionHit hit = new LNX_ProjectionHit();
				_serializedLnxNavmesh.SamplePosition( _test_samplePosition.testPositions[i], out hit, 10f );

				Debug.Log($"expecting '{_test_samplePosition.hitPositions[i]}', hit: '{hit.HitPosition}'");

				//Assert.AreEqual( _test_samplePosition.hitPositions[i], hit.Position ); //got rounding point issue
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.hitPositions[i].x, hit.HitPosition.x );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.hitPositions[i].y, hit.HitPosition.y );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.hitPositions[i].z, hit.HitPosition.z );

				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.triCenters[i].x, _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.x );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.triCenters[i].y, _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.y );
				UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_samplePosition.triCenters[i].z, _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.z );
			}
		}

		[Test]
		public void b2_Test_ClosestOnPerimeter()
		{
			Debug.Log($"Creating test object from json...");
			Debug.Log($"test object path: '{TDG_Manager.filePath_testData_sampleClosestPtOnPerim}'");

			if ( !File.Exists(TDG_Manager.filePath_testData_sampleClosestPtOnPerim) )
			{
				Debug.LogError($"PROBLEM!!!!! file at test path does not exist. Cannot perform test.");
				return;
			}

			#region SETUP CLOSEST ON PERIMETER TEST -----------------------------
			//_test_closestOnPerimeter = _sceneGeneratedLnxNavmesh.gameObject.AddComponent<TDG_SampleClosestPtOnPerimeter>();
			_test_closestOnPerimeter = _serializedLnxNavmesh.gameObject.AddComponent<TDG_SampleClosestPtOnPerimeter>();

			//Debug.Log ( File.Exists(filePath_test_closestOnPerimeter) );
			//Debug.Log( filePath_test_closestOnPerimeter );
			string jsonString = File.ReadAllText(TDG_Manager.filePath_testData_sampleClosestPtOnPerim);

			JsonUtility.FromJsonOverwrite(jsonString, _test_closestOnPerimeter);
			//Debug.Log( _test_samplePosition.problemPositions.Count );

			Assert.IsNotNull(_test_closestOnPerimeter.testPositions);
			Assert.Greater(_test_closestOnPerimeter.testPositions.Count, 0);
			#endregion

			for ( int i = 0; i < _test_closestOnPerimeter.testPositions.Count; i++ )
			{
				Debug.Log($"{i}. expecting: '{_test_closestOnPerimeter.hitPositions[i]}'...");

				LNX_ProjectionHit hit = new LNX_ProjectionHit();

				if ( _serializedLnxNavmesh.SamplePosition(_test_closestOnPerimeter.testPositions[i], out hit, 10f) ) //It needs to do this in order to decide which triangle to use...
				{
					Vector3 v_result = _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].ClosestPointOnPerimeter( _test_closestOnPerimeter.testPositions[i] );

					UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_closestOnPerimeter.hitPositions[i].x, v_result.x );
					UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_closestOnPerimeter.hitPositions[i].y, v_result.y );
					UnityEngine.Assertions.Assert.AreApproximatelyEqual( _test_closestOnPerimeter.hitPositions[i].z, v_result.z );
				}
			}
		}

		[Test]
		public void b3_Test_ClosestOnPerimeter_triCenters()
		{
			Debug.Log($"{nameof(b3_Test_ClosestOnPerimeter_triCenters)}---------------------------------------------------------");
			Debug.Log($"Sampling '{_test_closestOnPerimeter.testPositions.Count}' test positions at: '{System.DateTime.Now.ToString()}'");

			for (int i = 0; i < _test_closestOnPerimeter.testPositions.Count; i++)
			{
				Debug.Log($"{i}...");

				LNX_ProjectionHit hit = new LNX_ProjectionHit();

				if ( _serializedLnxNavmesh.SamplePosition(_test_closestOnPerimeter.testPositions[i], out hit, 10f)) //It needs to do this in order to decide which triangle to use...
				{
					Vector3 v_result = _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].ClosestPointOnPerimeter(_test_closestOnPerimeter.testPositions[i]);

					Debug.Log($"{i}. expecting: '{_test_closestOnPerimeter.hitPositions[i]}', ClosestPointOnPerimeter got: '{v_result}'. " +
						$"close: '{Vector3.Distance(v_result, _test_closestOnPerimeter.hitPositions[i])}'..");

					UnityEngine.Assertions.Assert.AreApproximatelyEqual(_test_closestOnPerimeter.triCenters[i].x, _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.x);
					UnityEngine.Assertions.Assert.AreApproximatelyEqual(_test_closestOnPerimeter.triCenters[i].y, _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.y);
					UnityEngine.Assertions.Assert.AreApproximatelyEqual(_test_closestOnPerimeter.triCenters[i].z, _serializedLnxNavmesh.Triangles[hit.Index_intersectedTri].V_center.z);
				}
			}

			Debug.Log($"end of test: '{nameof(b3_Test_ClosestOnPerimeter_triCenters)}'");
		}
		#endregion


		/*
		 * 
		[Test]
		public void x_Test_SelectCutEdge()
		{
			//make tests showing that I can and cannot cut edges in various scenarios
		}
		*/


		/*
        // A UnityTest behaves like a coroutine in Play Mode. In Edit Mode you can use
        // `yield return null;` to skip a frame.
        [UnityTest]
        public IEnumerator LNXEditModeTestsWithEnumeratorPasses()
        {
            // Use the Assert class to test conditions.
            // Use yield to skip a frame.

			yield return null;
        }
		*/

	}
}

